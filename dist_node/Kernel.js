'use strict';Object.defineProperty(exports,'__esModule',{value:true});exports.send=exports.spawn=undefined;var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break}}catch(err){_d=true;_e=err}finally{try{if(!_n&&_i['return'])_i['return']()}finally{if(_d)throw _e}}return _arr}return function(arr,i){if(Array.isArray(arr)){return arr}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i)}else{throw new TypeError('Invalid attempt to destructure non-iterable instance')}}}();var _ProcessList=require('./ProcessList');var ProcessList=_interopRequireWildcard(_ProcessList);var _ProcessInfo=require('./ProcessInfo');var _ProcessInfo2=_interopRequireDefault(_ProcessInfo);var _Pid=require('./Pid');var _Pid2=_interopRequireDefault(_Pid);var _Runner=require('./Runner');var _Runner2=_interopRequireDefault(_Runner);var _Console=require('./Console');function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj}else{var newObj={};if(obj!=null){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key))newObj[key]=obj[key]}}newObj.default=obj;return newObj}}function _asyncToGenerator(fn){return function(){var gen=fn.apply(this,arguments);return new Promise(function(resolve,reject){function step(key,arg){try{var info=gen[key](arg);var value=info.value}catch(error){reject(error);return}if(info.done){resolve(value)}else{return Promise.resolve(value).then(function(value){step('next',value)},function(err){step('throw',err)})}}return step('next')})}}let messages=[];exports.spawn=spawn;exports.send=send;function spawn(func,name){if(typeof func!=='function'){return[false,'Liquid.Kernel.spawn Process must be function']}const pId=_Pid2.default.new();if(typeof name==='string'&&name){const existing=ProcessList.getByRef(name);if(_ProcessInfo2.default.isAlive(existing)){return[false,'Liquid.Kernel.spawn Process name already taken']}}const pInfo=_ProcessInfo2.default.new(pId,runProcess(func,pId));_Console.debugConsole.log('> spawn',pId.toString());ProcessList.register(pId,pInfo);if(typeof name==='string'&&name){ProcessList.register(name,pInfo)}_ProcessInfo2.default.resolution(pInfo).then(tryPushMessages);return[true,pId]}function runProcess(func,pId){_Console.debugConsole.log('> runProcess',pId.toString());return new Promise((resolve,reject)=>{_Runner2.default.doNext(()=>{Promise.resolve().then(()=>func(()=>receive(pId),pId)).then(resolve,reject)})})}function send(pid,message){_Console.debugConsole.log('> send',stringify(pid),message);if(!pid){return[false,'Liquid.Kernel.send Empty ID']}if(!ProcessList.getByRef(pid)){return[false,'Liquid.Kernel.send Dead process']}return new Promise((()=>{var _ref=_asyncToGenerator(function*(resolve){messages.push([pid,message,function(msg){return _Runner2.default.doNext(resolve,[msg])}]);tryPushMessages()});return function(_x){return _ref.apply(this,arguments)}})())}function receive(pid){_Console.debugConsole.log('> receive',stringify(pid));return new Promise((resolve,reject)=>{const pInfo=ProcessList.getByRef(pid);if(!pInfo||!_ProcessInfo2.default.isAlive(pInfo)){reject(new Error('Liquid.Kernel.receive Reading process is marked as dead.'));return}_ProcessInfo2.default.pushRequestResolvers(pInfo,[resolve,reject]);tryPushMessages()})}let isPushingMessages=false;function tryPushMessages(){if(isPushingMessages)return;isPushingMessages=true;_Runner2.default.doNext(tryPushMessagesDeffered,[],3)}function tryPushMessagesDeffered(){_Console.debugConsole.log('> tryPushMessages',messages.length);if(!messages.length){isPushingMessages=false;return}const unhandledMessages=[];while(true){const takenEntries=messages.splice(0,1);if(takenEntries.length===0)break;const messagesEntry=takenEntries[0];var _messagesEntry=_slicedToArray(messagesEntry,3);const pid=_messagesEntry[0];const message=_messagesEntry[1];const acknowledgeSend=_messagesEntry[2];const pInfo=ProcessList.getByRef(pid);if(!pInfo){_Console.debugConsole.log('> tryPushMessages - process',stringify(pid),'does not exist');_Runner2.default.doNext(acknowledgeSend,[[false,'Liquid.Kernel.send Dead process']]);continue}if(!_ProcessInfo2.default.isAlive(pInfo)){_Console.debugConsole.log('> tryPushMessages - process',stringify(pid),'dead');_Runner2.default.doNext(acknowledgeSend,[[false,'Liquid.Kernel.send Dead process']]);continue}const receiveResolvers=_ProcessInfo2.default.takeRequestResolvers(pInfo);if(!receiveResolvers){_Console.debugConsole.log('> tryPushMessages - process',stringify(pid),'NOT receiving');unhandledMessages.push(messagesEntry);continue}var _receiveResolvers=_slicedToArray(receiveResolvers,1);const pushToReceive=_receiveResolvers[0];_Console.debugConsole.log('> tryPushMessages - process',stringify(pid),'receiving');_Runner2.default.doNext(pushToReceive,[message],2);_Runner2.default.doNext(acknowledgeSend,[[true,'ok']],1)}_Console.debugConsole.log('> tryPushMessages, unhandled:',unhandledMessages.length);messages=unhandledMessages;isPushingMessages=false}function stringify(subject){if(subject&&subject.toString){return subject.toString()}}